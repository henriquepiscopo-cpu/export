import os
import re
import certifi
import requests
import pandas as pd
from io import BytesIO, StringIO
from datetime import date
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from openpyxl import load_workbook

# ================= CONFIG (AJUSTE AQUI) =================
PLANILHA_MAE_PATH = r"C:\Users\i467182\Documents\Code\Projetim\MinhaPlanilhaMae.xlsm"  # <-- MUDE AQUI
ABA_DESTINO = "python"
# ========================================================

URL = "https://www.debentures.com.br/exploreosnd/consultaadados/mercadosecundario/MercSecMes.aspx"

HEADERS = {
    "User-Agent": "Mozilla/5.0",
    "Accept": "*/*",
    "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8",
    "Connection": "close",
    "Referer": "https://www.debentures.com.br/",
}

# ----------------------- HTTP -----------------------
def build_session() -> requests.Session:
    s = requests.Session()
    s.trust_env = True
    retry = Retry(
        total=7,
        backoff_factor=0.8,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET", "POST"],
        raise_on_status=False,
    )
    s.mount("https://", HTTPAdapter(max_retries=retry))
    return s

# ----------------------- Datas -----------------------
def mes_ano_anterior(ref=None):
    ref = ref or date.today()
    if ref.month == 1:
        return 12, ref.year - 1
    return ref.month - 1, ref.year

def current_period_from_html(html: str) -> str:
    m = re.search(r"\b(\d{1,2})/(\d{4})\b", html or "")
    if not m:
        return ""
    return f"{int(m.group(1))}/{m.group(2)}"

# ----------------------- WebForms helpers -----------------------
def parse_hidden(html: str) -> dict:
    hidden = {}
    for name in ["__VIEWSTATE", "__EVENTVALIDATION", "__VIEWSTATEGENERATOR"]:
        m = re.search(rf'id="{re.escape(name)}"\s+value="([^"]*)"', html, flags=re.I)
        if m:
            hidden[name] = m.group(1)
    return hidden

def find_eventtargets(html: str) -> dict:
    ids = re.findall(r'id="(ctl00_ContentPlaceHolder1_[^"]+)"', html, flags=re.I)

    export_id = None
    prev_id = None

    for i in ids:
        low = i.lower()
        if export_id is None and low.endswith("_lnkex"):
            export_id = i
        if prev_id is None and ("mes" in low) and (("ant" in low) or ("prev" in low)):
            prev_id = i

    return {"export": export_id, "prev": prev_id, "all": ids}

def postback(s: requests.Session, eventtarget_id: str, hidden: dict) -> requests.Response:
    eventtarget = eventtarget_id.replace("_", "$")
    data = {
        "__EVENTTARGET": eventtarget,
        "__EVENTARGUMENT": "",
        "__VIEWSTATE": hidden.get("__VIEWSTATE", ""),
        "__VIEWSTATEGENERATOR": hidden.get("__VIEWSTATEGENERATOR", ""),
        "__EVENTVALIDATION": hidden.get("__EVENTVALIDATION", ""),
    }
    r = s.post(URL, data=data, headers=HEADERS, timeout=(10, 180), verify=certifi.where())
    r.raise_for_status()
    return r

# ----------------------- Download em mem√≥ria -----------------------
def baixar_mes_anterior_em_memoria() -> bytes:
    target_m, target_y = mes_ano_anterior()
    target_label = f"{target_m}/{target_y}"

    s = build_session()

    r0 = s.get(URL, headers=HEADERS, timeout=(10, 60), verify=certifi.where())
    r0.raise_for_status()
    html = r0.text

    hidden = parse_hidden(html)
    ids = find_eventtargets(html)

    if not ids["export"]:
        raise RuntimeError("N√£o achei o controle de export (lnkex) no HTML.")
    if not ids["prev"]:
        candidates = [i for i in ids["all"] if "mes" in i.lower()]
        raise RuntimeError(
            "N√£o achei o controle de m√™s anterior no HTML.\n"
            f"Candidatos com 'Mes': {candidates[:40]}"
        )

    cur = current_period_from_html(html)
    if not cur:
        raise RuntimeError("N√£o consegui detectar o per√≠odo atual (mm/aaaa) na p√°gina.")

    print("Per√≠odo inicial:", cur, "| alvo:", target_label)

    for _ in range(36):
        if cur == target_label:
            break
        r = postback(s, ids["prev"], hidden)
        html = r.text
        hidden = parse_hidden(html)
        cur = current_period_from_html(html)
        if cur:
            print("Agora:", cur)

    if cur != target_label:
        raise RuntimeError(f"N√£o consegui chegar no alvo {target_label}. Parei em {cur}.")

    r_export = postback(s, ids["export"], hidden)

    cdisp = (r_export.headers.get("Content-Disposition") or "").lower()
    if "attachment" not in cdisp:
        debug_path = os.path.join(os.path.dirname(PLANILHA_MAE_PATH), "debug_export.html")
        with open(debug_path, "w", encoding="utf-8") as f:
            f.write(r_export.text)
        raise RuntimeError(f"Export n√£o retornou arquivo. Salvei {debug_path}")

    return r_export.content

# ----------------------- Leitura robusta (XLS ou HTML) -----------------------
def ler_xls_em_memoria(xls_bytes: bytes) -> pd.DataFrame:
    # 1) tenta XLS bin√°rio
    try:
        return pd.read_excel(BytesIO(xls_bytes), engine="xlrd")
    except Exception:
        # 2) fallback: HTML disfar√ßado de XLS
        html = xls_bytes.decode("latin1", errors="ignore")
        dfs = pd.read_html(StringIO(html))
        if not dfs:
            raise RuntimeError("N√£o encontrei tabelas no HTML retornado.")
        return dfs[0]

# ----------------------- Colar A:F na planilha-m√£e -----------------------
def colar_A_F_na_planilha_mae(df: pd.DataFrame):
    if not os.path.exists(PLANILHA_MAE_PATH):
        raise FileNotFoundError(f"N√£o achei a planilha-m√£e em: {PLANILHA_MAE_PATH}")

    keep_vba = PLANILHA_MAE_PATH.lower().endswith(".xlsm")
    wb = load_workbook(PLANILHA_MAE_PATH, keep_vba=keep_vba)

    if ABA_DESTINO not in wb.sheetnames:
        raise RuntimeError(f"Aba '{ABA_DESTINO}' n√£o existe. Abas: {wb.sheetnames}")

    ws = wb[ABA_DESTINO]

    # pega s√≥ as 6 primeiras colunas (A-F). Se tiver menos, completa.
    df6 = df.copy()
    if df6.shape[1] < 6:
        # adiciona colunas vazias at√© dar 6
        for k in range(6 - df6.shape[1]):
            df6[f"col_vazia_{k+1}"] = None
    df6 = df6.iloc[:, :6]

    # n√∫mero de linhas a escrever (inclui header)
    new_rows = len(df6) + 1  # +1 header
    old_rows = ws.max_row if ws.max_row else 0

    # 1) limpa A:F do que j√° existe (at√© o maior entre antigo e novo)
    max_rows_to_clear = max(old_rows, new_rows)
    for r in range(1, max_rows_to_clear + 1):
        for c in range(1, 7):  # A=1 ... F=6
            ws.cell(row=r, column=c).value = None

    # 2) escreve header em A1:F1
    for c, col_name in enumerate(df6.columns, start=1):
        ws.cell(row=1, column=c, value=str(col_name))

    # 3) escreve dados a partir da linha 2 (A2:F...)
    for r_idx, row in enumerate(df6.itertuples(index=False), start=2):
        for c_idx, val in enumerate(row, start=1):
            ws.cell(row=r_idx, column=c_idx, value=val)

    wb.save(PLANILHA_MAE_PATH)

# ----------------------- MAIN -----------------------
if __name__ == "__main__":
    m, y = mes_ano_anterior()
    print(f"‚úî Vou baixar exatamente (m√™s anterior): {m:02d}/{y}")

    print("üì• Baixando Mercado Secund√°rio em mem√≥ria...")
    xls_bytes = baixar_mes_anterior_em_memoria()

    print("üìä Lendo retorno em mem√≥ria (XLS/HTML)...")
    df = ler_xls_em_memoria(xls_bytes)

    print(f"üìÑ Colando A:F na planilha-m√£e ({PLANILHA_MAE_PATH}) na aba '{ABA_DESTINO}'...")
    colar_A_F_na_planilha_mae(df)

    print("‚úÖ Conclu√≠do: colunas A-F atualizadas na aba 'python'.")
