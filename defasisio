import os
import re
import certifi
import requests
import pandas as pd
from io import BytesIO
from datetime import date
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from openpyxl import load_workbook

# ================= CONFIG (AJUSTE AQUI) =================
PLANILHA_MAE_PATH = r"/Users/henriquepiscopo/bradesco/MinhaPlanilhaMae.xlsm"  # <-- MUDE AQUI
ABA_DESTINO = "python"
# ========================================================

URL = "https://www.debentures.com.br/exploreosnd/consultaadados/mercadosecundario/MercSecMes.aspx"

HEADERS = {
    "User-Agent": "Mozilla/5.0",
    "Accept": "*/*",
    "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8",
    "Connection": "close",
    "Referer": "https://www.debentures.com.br/",
}


# ----------------------- HTTP -----------------------
def build_session() -> requests.Session:
    s = requests.Session()
    s.trust_env = True

    retry = Retry(
        total=7,
        backoff_factor=0.8,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET", "POST"],
        raise_on_status=False,
    )
    s.mount("https://", HTTPAdapter(max_retries=retry))
    return s


# ----------------------- Datas -----------------------
def mes_ano_anterior(ref=None):
    ref = ref or date.today()
    if ref.month == 1:
        return 12, ref.year - 1
    return ref.month - 1, ref.year


def normalize_period_label(label: str) -> str:
    """
    Normaliza '01/2026' -> '1/2026'
    """
    m = re.search(r"\b(\d{1,2})/(\d{4})\b", label or "")
    if not m:
        return ""
    return f"{int(m.group(1))}/{m.group(2)}"


def current_period_from_html(html: str) -> str:
    m = re.search(r"\b(\d{1,2})/(\d{4})\b", html or "")
    if not m:
        return ""
    return f"{int(m.group(1))}/{m.group(2)}"


# ----------------------- WebForms helpers -----------------------
def parse_hidden(html: str) -> dict:
    """
    Pega __VIEWSTATE, __EVENTVALIDATION, __VIEWSTATEGENERATOR
    """
    hidden = {}
    for name in ["__VIEWSTATE", "__EVENTVALIDATION", "__VIEWSTATEGENERATOR"]:
        m = re.search(rf'id="{re.escape(name)}"\s+value="([^"]*)"', html, flags=re.I)
        if m:
            hidden[name] = m.group(1)
    return hidden


def find_eventtargets(html: str) -> dict:
    """
    Descobre ids Ãºteis na pÃ¡gina:
      - export: ..._lnkex  (vocÃª jÃ¡ capturou via __EVENTTARGET) 
      - prev: algo com 'Mes' + ('Ant' ou 'Prev')  (mÃªs anterior)
      - next: algo com 'Mes' + ('Prox' ou 'Next') (mÃªs prÃ³ximo)
    """
    ids = re.findall(r'id="(ctl00_ContentPlaceHolder1_[^"]+)"', html, flags=re.I)

    export_id = None
    prev_id = None
    next_id = None

    for i in ids:
        low = i.lower()

        # export costuma ser lnkex
        if export_id is None and low.endswith("_lnkex"):
            export_id = i

        # mÃªs anterior
        if prev_id is None and ("mes" in low) and (("ant" in low) or ("prev" in low)):
            prev_id = i

        # mÃªs prÃ³ximo
        if next_id is None and ("mes" in low) and (("prox" in low) or ("next" in low)):
            next_id = i

    return {"export": export_id, "prev": prev_id, "next": next_id, "all": ids}


def postback(s: requests.Session, eventtarget_id: str, hidden: dict) -> requests.Response:
    """
    eventtarget_id vem no formato HTML id: ctl00_ContentPlaceHolder1_lnkex
    mas o WebForms espera: ctl00$ContentPlaceHolder1$lnkex
    """
    if not eventtarget_id:
        raise RuntimeError("eventtarget_id vazio.")

    eventtarget = eventtarget_id.replace("_", "$")

    data = {
        "__EVENTTARGET": eventtarget,
        "__EVENTARGUMENT": "",
        "__VIEWSTATE": hidden.get("__VIEWSTATE", ""),
        "__VIEWSTATEGENERATOR": hidden.get("__VIEWSTATEGENERATOR", ""),
        "__EVENTVALIDATION": hidden.get("__EVENTVALIDATION", ""),
    }

    r = s.post(URL, data=data, headers=HEADERS, timeout=(10, 180), verify=certifi.where())
    r.raise_for_status()
    return r


# ----------------------- Download em memÃ³ria -----------------------
def baixar_mes_anterior_em_memoria() -> bytes:
    target_m, target_y = mes_ano_anterior()
    target_label = normalize_period_label(f"{target_m}/{target_y}")

    s = build_session()

    # GET inicial
    r0 = s.get(URL, headers=HEADERS, timeout=(10, 60), verify=certifi.where())
    r0.raise_for_status()
    html = r0.text

    hidden = parse_hidden(html)
    ids = find_eventtargets(html)

    if not ids["export"]:
        raise RuntimeError("NÃ£o achei o controle de export (lnkex) no HTML.")
    if not ids["prev"]:
        # debug rÃ¡pido: lista candidatos relacionados a 'Mes'
        candidates = [i for i in ids["all"] if "mes" in i.lower()]
        raise RuntimeError(
            "NÃ£o achei o controle de mÃªs anterior (MesAnt/MesPrev) no HTML.\n"
            f"Candidatos relacionados a 'Mes': {candidates[:40]}"
        )

    cur = normalize_period_label(current_period_from_html(html))
    if not cur:
        raise RuntimeError("NÃ£o consegui detectar o perÃ­odo atual (mm/aaaa) na pÃ¡gina.")

    print("PerÃ­odo inicial:", cur, "| alvo:", target_label)

    # navega mÃªs a mÃªs atÃ© o alvo (normalmente 1 clique, mas deixo genÃ©rico)
    for _ in range(36):
        if cur == target_label:
            break
        r = postback(s, ids["prev"], hidden)
        html = r.text
        hidden = parse_hidden(html)
        cur = normalize_period_label(current_period_from_html(html))
        if cur:
            print("Agora:", cur)

    if cur != target_label:
        raise RuntimeError(f"NÃ£o consegui chegar no alvo {target_label}. Parei em {cur}.")

    # exporta (bytes em memÃ³ria)
    r_export = postback(s, ids["export"], hidden)

    cdisp = (r_export.headers.get("Content-Disposition") or "").lower()
    if "attachment" not in cdisp:
        # salva debug opcional ao lado da planilha-mÃ£e (pra vocÃª inspecionar se necessÃ¡rio)
        debug_path = os.path.join(os.path.dirname(PLANILHA_MAE_PATH), "debug_export.html")
        with open(debug_path, "w", encoding="utf-8") as f:
            f.write(r_export.text)
        raise RuntimeError(f"Export nÃ£o retornou arquivo. Salvei {debug_path}")

    return r_export.content


def ler_xls_em_memoria(xls_bytes: bytes) -> pd.DataFrame:
    # precisa de: pip install xlrd
    return pd.read_excel(BytesIO(xls_bytes), engine="xlrd")


# ----------------------- Colar na planilha-mÃ£e -----------------------
def colar_na_planilha_mae(df: pd.DataFrame):
    if not os.path.exists(PLANILHA_MAE_PATH):
        raise FileNotFoundError(f"NÃ£o achei a planilha-mÃ£e em: {PLANILHA_MAE_PATH}")

    keep_vba = PLANILHA_MAE_PATH.lower().endswith(".xlsm")
    wb = load_workbook(PLANILHA_MAE_PATH, keep_vba=keep_vba)

    if ABA_DESTINO not in wb.sheetnames:
        raise RuntimeError(f"Aba '{ABA_DESTINO}' nÃ£o existe. Abas: {wb.sheetnames}")

    ws = wb[ABA_DESTINO]

    # limpa tudo da aba
    if ws.max_row > 0:
        ws.delete_rows(1, ws.max_row)

    # escreve cabeÃ§alho
    for col_idx, col in enumerate(df.columns, start=1):
        ws.cell(row=1, column=col_idx, value=str(col))

    # escreve dados
    for r_idx, row in enumerate(df.itertuples(index=False), start=2):
        for c_idx, val in enumerate(row, start=1):
            ws.cell(row=r_idx, column=c_idx, value=val)

    wb.save(PLANILHA_MAE_PATH)


# ----------------------- MAIN -----------------------
if __name__ == "__main__":
    m, y = mes_ano_anterior()
    print(f"âœ” Vou baixar exatamente (mÃªs anterior): {m:02d}/{y}")

    print("ðŸ“¥ Baixando Mercado SecundÃ¡rio em memÃ³ria...")
    xls_bytes = baixar_mes_anterior_em_memoria()

    print("ðŸ“Š Lendo XLS em memÃ³ria...")
    df = ler_xls_em_memoria(xls_bytes)

    print(f"ðŸ“„ Colando na planilha-mÃ£e ({PLANILHA_MAE_PATH}) na aba '{ABA_DESTINO}'...")
    colar_na_planilha_mae(df)

    print("âœ… ConcluÃ­do: dados atualizados na planilha-mÃ£e.")
