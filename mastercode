import re
from io import StringIO
from datetime import datetime, date, timedelta
from pathlib import Path
from typing import Dict, Optional

import pandas as pd
import requests
from openpyxl import load_workbook


# =========================
# AJUSTE AQUI
# =========================
EXCEL_PATH = Path("volume negociado.xlsx")
SHEET_NAME = "Planilha1"
DATE_COL_EXCEL = "D"

COLUMN_MAP: Dict[str, str] = {
    "Data": "D",
    "Volume Negociado em Moeda da Época": "E",
}

START_FROM_NEXT_DAY = True

URL_FORM = "https://www.debentures.com.br/exploreosnd/consultaadados/mercadosecundario/volumesnegociados_f.asp"
URL_POST = "https://www.debentures.com.br/exploreosnd/consultaadados/mercadosecundario/volumesnegociados_r.asp"


# =========================
# HELPERS
# =========================
_PTBR_NUM = re.compile(r"^\s*\d{1,3}(\.\d{3})+(,\d+)?\s*$")   # 1.234.567,89 (ou sem decimais)
_ENUS_NUM = re.compile(r"^\s*\d{1,3}(,\d{3})+(\.\d+)?\s*$")   # 1,234,567.89

def to_number(x) -> Optional[float]:
    """
    Converte com segurança para float:
    - Se já for número, devolve float (sem mexer).
    - Se for string pt-BR (1.234.567,89), converte certo.
    - Se for string en-US (1,234,567.89), converte certo.
    - Se for string simples (1234,56 ou 1234.56), também converte.
    """
    if x is None or pd.isna(x):
        return None

    if isinstance(x, (int, float)):
        return float(x)

    s = str(x).strip()
    if s == "" or s.lower() in {"nan", "none", "-"}:
        return None

    # remove moeda/espaços
    s = re.sub(r"[R$\s]", "", s)

    # pt-BR clássico: 1.234.567,89
    if _PTBR_NUM.match(s):
        s = s.replace(".", "").replace(",", ".")
        try:
            return float(s)
        except:
            return None

    # en-US clássico: 1,234,567.89
    if _ENUS_NUM.match(s):
        s = s.replace(",", "")
        try:
            return float(s)
        except:
            return None

    # casos simples: "1234,56" ou "1234.56"
    if s.count(",") == 1 and s.count(".") == 0:
        try:
            return float(s.replace(",", "."))
        except:
            return None

    if s.count(".") == 1 and s.count(",") == 0:
        try:
            return float(s)
        except:
            return None

    # fallback: remove separadores estranhos, tenta último separador como decimal
    # ex: "3.389.483.70408" (sem vírgula) -> isso é suspeito; melhor NÃO inventar
    # então tenta só dígitos
    only = re.sub(r"[^\d\-]", "", s)
    if only and only != s:
        try:
            return float(only)
        except:
            return None

    return None

def parse_excel_date(v) -> Optional[date]:
    if v is None:
        return None
    if isinstance(v, datetime):
        return v.date()
    if isinstance(v, date):
        return v
    s = str(v).strip()
    if not s:
        return None
    for fmt in ("%d/%m/%Y", "%Y-%m-%d", "%d-%m-%Y"):
        try:
            return datetime.strptime(s, fmt).date()
        except:
            pass
    return None

def find_last_date_in_excel(path: Path, sheet: str, date_col: str) -> date:
    wb = load_workbook(path)
    if sheet not in wb.sheetnames:
        raise KeyError(f"Aba '{sheet}' não existe. Abas disponíveis: {wb.sheetnames}")
    ws = wb[sheet]

    last_row = ws.max_row
    while last_row > 1 and ws[f"{date_col}{last_row}"].value in (None, ""):
        last_row -= 1

    last_val = ws[f"{date_col}{last_row}"].value
    d = parse_excel_date(last_val)
    if d is None:
        raise RuntimeError(f"Não consegui ler a última data em {sheet}!{date_col}{last_row}. Valor={last_val!r}")
    return d

def excel_next_append_row(path: Path, sheet: str, date_col: str) -> int:
    wb = load_workbook(path)
    ws = wb[sheet]
    r = ws.max_row
    while r > 1 and ws[f"{date_col}{r}"].value in (None, ""):
        r -= 1
    return r + 1

def format_br(d: date) -> str:
    return d.strftime("%d/%m/%Y")


# =========================
# FETCH TABLE
# =========================
def fetch_table(dt_ini: date, dt_fim: date) -> pd.DataFrame:
    s = requests.Session()
    headers_get = {
        "User-Agent": "Mozilla/5.0",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8",
    }

    s.get(URL_FORM, headers=headers_get, timeout=30).raise_for_status()

    headers_post = {
        "User-Agent": headers_get["User-Agent"],
        "Accept": headers_get["Accept"],
        "Accept-Language": headers_get["Accept-Language"],
        "Content-Type": "application/x-www-form-urlencoded",
        "Origin": "https://www.debentures.com.br",
        "Referer": URL_FORM,
    }

    form = {
        "op_exc": "False",
        "dt_ini": format_br(dt_ini),
        "dt_fim": format_br(dt_fim),
        "Submit32.x": "31",
        "Submit32.y": "13",
    }

    r = s.post(URL_POST, headers=headers_post, data=form, timeout=60)
    r.raise_for_status()
    html = r.text

    # IMPORTANTE: sem thousands/decimal aqui; vamos converter nós mesmos com segurança
    tables = pd.read_html(StringIO(html), header=None)
    if not tables:
        Path("debug_volumesnegociados.html").write_text(html, encoding="utf-8")
        raise RuntimeError("Não encontrei tabela no HTML (salvei debug_volumesnegociados.html).")

    date_regex = re.compile(r"^\s*\d{2}/\d{2}/\d{4}\s*$")

    chosen = None
    for t in tables:
        for c in t.columns:
            hits = t[c].astype(str).str.strip().str.match(date_regex, na=False).sum()
            if hits >= 1:
                chosen = t.copy()
                break
        if chosen is not None:
            break

    if chosen is None:
        Path("debug_volumesnegociados.html").write_text(html, encoding="utf-8")
        raise RuntimeError("Não achei coluna com datas dd/mm/aaaa. Salvei debug_volumesnegociados.html.")

    df_raw = chosen.copy()

    # tenta achar header
    header_row = None
    for i in range(min(25, len(df_raw))):
        row_txt = df_raw.iloc[i].astype(str).str.strip().str.lower().tolist()
        has_data = any("data" in x for x in row_txt)
        has_vol = any("volume" in x for x in row_txt)
        if has_data and has_vol:
            header_row = i
            break

    if header_row is not None:
        headers = df_raw.iloc[header_row].astype(str).str.strip().tolist()
        df = df_raw.iloc[header_row + 1 :].copy()
        df.columns = headers
    else:
        df = df_raw.copy()
        df = df.rename(columns={0: "Data", 1: "Volume Negociado em Moeda da Época"})

    df.columns = [str(c).strip() for c in df.columns]

    # garante Data
    if "Data" not in df.columns:
        cand = None
        for c in df.columns:
            hits = df[c].astype(str).str.strip().str.match(date_regex, na=False).sum()
            if hits >= 1:
                cand = c
                break
        if cand is None:
            raise RuntimeError(f"Não consegui identificar coluna Data. Colunas: {list(df.columns)}")
        df = df.rename(columns={cand: "Data"})

    # garante volume
    if "Volume Negociado em Moeda da Época" not in df.columns:
        non_data_cols = [c for c in df.columns if c != "Data"]
        if non_data_cols:
            df = df.rename(columns={non_data_cols[0]: "Volume Negociado em Moeda da Época"})

    # converte Data
    df["Data"] = pd.to_datetime(df["Data"].astype(str).str.strip(), dayfirst=True, errors="coerce").dt.date
    df = df[df["Data"].notna()].copy()

    # converte Volume de forma segura (pt-BR)
    if "Volume Negociado em Moeda da Época" in df.columns:
        df["Volume Negociado em Moeda da Época"] = df["Volume Negociado em Moeda da Época"].apply(to_number)

    df = df.sort_values("Data").reset_index(drop=True)
    df = df[["Data", "Volume Negociado em Moeda da Época"]].copy()

    return df


# =========================
# APPEND TO EXCEL
# =========================
def append_to_excel(df: pd.DataFrame, path: Path, sheet: str, date_col_excel: str, col_map: Dict[str, str]) -> int:
    wb = load_workbook(path)
    ws = wb[sheet]

    start_row = excel_next_append_row(path, sheet, date_col_excel)

    key_data = next((k for k in col_map.keys() if str(k).strip().lower() == "data"), None)
    if not key_data:
        raise RuntimeError("COLUMN_MAP precisa ter a chave 'Data' apontando para a coluna de data no Excel.")

    missing = [c for c in col_map.keys() if c not in df.columns]
    if missing:
        raise RuntimeError(
            f"Seu COLUMN_MAP tem colunas que não existem no retorno: {missing}\n"
            f"Colunas disponíveis: {list(df.columns)}"
        )

    row = start_row
    for _, r in df.iterrows():
        # Data
        ws[f"{col_map[key_data]}{row}"].value = r.get(key_data)

        # demais colunas (numéricas)
        for site_col, excel_col in col_map.items():
            if str(site_col).strip().lower() == "data":
                continue

            val = r.get(site_col)
            num = to_number(val)
            if num is None:
                ws[f"{excel_col}{row}"].value = None
            else:
                ws[f"{excel_col}{row}"].value = round(float(num), 2)  # GARANTE 2 casas

        row += 1

    # formatos
    date_excel_col = col_map[key_data]
    for rr in range(start_row, row):
        ws[f"{date_excel_col}{rr}"].number_format = "DD/MM/YYYY"

    for site_col, excel_col in col_map.items():
        if str(site_col).strip().lower() != "data":
            for rr in range(start_row, row):
                ws[f"{excel_col}{rr}"].number_format = "#,##0.00"

    wb.save(path)
    return row - start_row


# =========================
# MAIN
# =========================
def main():
    if not EXCEL_PATH.exists():
        raise FileNotFoundError(f"Não achei o arquivo: {EXCEL_PATH.resolve()}")

    last = find_last_date_in_excel(EXCEL_PATH, SHEET_NAME, DATE_COL_EXCEL)
    today = datetime.now().date()

    dt_ini = last + timedelta(days=1) if START_FROM_NEXT_DAY else last
    dt_fim = today

    if dt_ini > dt_fim:
        print(f"[OK] Nada a fazer. Última data ({last}) já é >= hoje ({today}).")
        return

    print(f"[INFO] Planilha: última data={last} | Vou buscar: {dt_ini} até {dt_fim}")

    df = fetch_table(dt_ini, dt_fim)
    df = df[df["Data"] >= dt_ini].copy()

    print("[INFO] Colunas:", list(df.columns))
    print("[INFO] Preview:\n", df.head(3))

    n = append_to_excel(df, EXCEL_PATH, SHEET_NAME, DATE_COL_EXCEL, COLUMN_MAP)
    print(f"[OK] Adicionei {n} linhas em {EXCEL_PATH} / {SHEET_NAME}.")


if __name__ == "__main__":
    main()
