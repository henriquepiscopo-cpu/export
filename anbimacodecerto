import os
import requests
import pandas as pd
from datetime import date, timedelta
from io import BytesIO

# ================= CONFIGURA√á√ïES =================
BASE_URL = "https://www.anbima.com.br/informacoes/merc-sec-debentures/arqs"
EXCEL_DESTINO = "MercadoSecundario_ANBIMA.xlsx"

ABA_DI_FONTE = "DI_PERCENTUAL"
ABA_IPCA_FONTE = "IPCA_SPREAD"

HEADERS = {
    "User-Agent": "Mozilla/5.0",
    "Referer": "https://www.anbima.com.br/",
    # (Opcional, mas ajuda alguns servidores)
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8",
}

MESES_EN = {
    1: "jan", 2: "feb", 3: "mar", 4: "abr",
    5: "mai", 6: "jun", 7: "jul", 8: "aug",
    9: "set", 10: "out", 11: "nov", 12: "dez",
}

# üîß Janela de busca (dias corridos para tr√°s, varrendo dia a dia)
# Coloque um n√∫mero que certamente cubra o intervalo que o site mant√©m.
DIAS_CORRIDOS_VARREDURA = 15
# =================================================


def montar_url(dt: date) -> str:
    yy = dt.strftime("%y")
    dd = dt.strftime("%d")
    mon = MESES_EN[dt.month]
    return f"{BASE_URL}/d{yy}{mon}{dd}.xls"


def baixar_excel(dt: date) -> BytesIO | None:
    """
    Baixa o arquivo e s√≥ aceita se for XLS antigo (OLE).
    Se vier HTML/erro com status 200, rejeita e mostra preview no terminal.
    """
    url = montar_url(dt)
    resp = requests.get(url, headers=HEADERS, timeout=30, allow_redirects=True)

    ct = (resp.headers.get("Content-Type") or "").lower()
    size = len(resp.content or b"")

    ole_sig = b"\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1"
    is_xls_ole = size >= 8 and resp.content[:8] == ole_sig

    if resp.status_code != 200 or not resp.content:
        print(f"   ‚Ü≥ ‚ùå status={resp.status_code} size={size} ct={ct}")
        return None

    if not is_xls_ole:
        preview = resp.content[:160]
        print(f"   ‚Ü≥ ‚ùå n√£o √© XLS (status={resp.status_code} size={size} ct={ct}) preview={preview!r}")
        return None

    return BytesIO(resp.content)


def _achar_linha_cabecalho(df_raw: pd.DataFrame) -> int | None:
    """
    Procura a linha onde come√ßa a tabela (cont√©m 'C√≥digo' e 'Nome').
    """
    alvo1 = "c√≥digo"
    alvo2 = "nome"
    for i in range(min(len(df_raw), 140)):
        linha = df_raw.iloc[i].astype(str).str.strip().str.lower()
        if (linha == alvo1).any() and (linha == alvo2).any():
            return i
    return None


def _cortar_ate_fim_tabela(df: pd.DataFrame) -> pd.DataFrame:
    """
    Corta observa√ß√µes/rodap√©: mant√©m at√© a √∫ltima linha onde a 1¬™ coluna tem conte√∫do.
    """
    if df.empty:
        return df

    primeira = df.columns[0]
    serie = df[primeira]
    valido = serie.notna() & (serie.astype(str).str.strip() != "")

    if not valido.any():
        return df.reset_index(drop=True)

    ultimo_idx = valido[valido].index.max()
    return df.loc[:ultimo_idx].reset_index(drop=True)


def ler_aba_limpa(excel_bytes: BytesIO, aba: str) -> pd.DataFrame:
    """
    L√™ a aba e devolve s√≥ a tabela (sem t√≠tulos/observa√ß√µes), preservando ordem original.
    """
    print(f"üìä Lendo aba: {aba}")

    df_raw = pd.read_excel(excel_bytes, sheet_name=aba, header=None)
    idx_header = _achar_linha_cabecalho(df_raw)

    if idx_header is None:
        print("‚ö†Ô∏è Cabe√ßalho n√£o detectado; usando fallback header=0")
        df = pd.read_excel(excel_bytes, sheet_name=aba, header=0).dropna(how="all")
        df = _cortar_ate_fim_tabela(df)
        print(f"‚úÖ Aba {aba} (fallback): {len(df)} linhas, {len(df.columns)} colunas")
        return df

    header = df_raw.iloc[idx_header].astype(str).str.strip().tolist()
    df = df_raw.iloc[idx_header + 1 :].copy()
    df.columns = header
    df = df.dropna(how="all")

    # remove colunas vazias/Unnamed
    cols_validas = []
    for c in df.columns:
        nome = str(c).strip()
        if nome and not nome.lower().startswith("unnamed"):
            cols_validas.append(c)
    df = df[cols_validas]

    df = _cortar_ate_fim_tabela(df)
    print(f"‚úÖ Aba {aba}: {len(df)} linhas, {len(df.columns)} colunas")
    return df


def _ler_duas_abas(bytes_ok: BytesIO) -> tuple[pd.DataFrame, pd.DataFrame]:
    di = ler_aba_limpa(bytes_ok, ABA_DI_FONTE)
    bytes_ok.seek(0)
    ipca = ler_aba_limpa(bytes_ok, ABA_IPCA_FONTE)
    return di, ipca


def nome_data(dt: date) -> str:
    return dt.strftime("%d-%m-%Y")


def achar_mais_recente_e_mais_antigo_disponiveis() -> tuple[tuple[date, BytesIO], tuple[date, BytesIO]] | None:
    """
    Varre dia-a-dia para tr√°s (ignorando fim de semana) e identifica:
    - MAIS RECENTE: primeiro XLS v√°lido encontrado
    - MAIS ANTIGO: √∫ltimo XLS v√°lido encontrado dentro da janela varrida
    """
    print("\nüöÄ Procurando datas dispon√≠veis no site (varrendo dia a dia)...")

    dt = date.today()

    mais_recente = None
    mais_antigo = None

    varridos = 0
    while varridos < DIAS_CORRIDOS_VARREDURA:
        varridos += 1

        # ignora fim de semana (se quiser checar fim de semana tamb√©m, remova este if)
        if dt.weekday() >= 5:
            dt -= timedelta(days=1)
            continue

        url = montar_url(dt)
        print(f"üîé Tentando {dt.strftime('%d/%m/%Y')} | {url}")

        b = baixar_excel(dt)
        if b is not None:
            print(f"‚úÖ XLS v√°lido em {dt.strftime('%d/%m/%Y')}")
            if mais_recente is None:
                mais_recente = (dt, b)
                print(f"üìå MAIS RECENTE = {dt.strftime('%d/%m/%Y')}")
            mais_antigo = (dt, b)
        else:
            print("‚ùå Sem XLS v√°lido")

        dt -= timedelta(days=1)

    if mais_recente is None or mais_antigo is None:
        print("\n‚ö†Ô∏è N√£o encontrei nenhum XLS v√°lido na janela varrida.")
        return None

    print("\n‚úÖ Datas escolhidas:")
    print(f"   - MAIS RECENTE: {mais_recente[0].strftime('%d/%m/%Y')}")
    print(f"   - MAIS ANTIGO:  {mais_antigo[0].strftime('%d/%m/%Y')}\n")

    return mais_recente, mais_antigo


def main():
    print("\nüöÄ Iniciando atualiza√ß√£o ANBIMA (mais recente + mais antigo)\n")

    achado = achar_mais_recente_e_mais_antigo_disponiveis()
    if achado is None:
        return

    (dt_rec, bytes_rec), (dt_old, bytes_old) = achado

    print("=== 1) Extraindo tabelas da data MAIS RECENTE ===")
    di_rec, ipca_rec = _ler_duas_abas(bytes_rec)

    print("\n=== 2) Extraindo tabelas da data MAIS ANTIGA ===")
    di_old, ipca_old = _ler_duas_abas(bytes_old)

    print("\n=== 3) Salvando no Excel destino ===")
    mode = "a" if os.path.exists(EXCEL_DESTINO) else "w"
    writer_kwargs = {"if_sheet_exists": "replace"} if mode == "a" else {}

    with pd.ExcelWriter(EXCEL_DESTINO, engine="openpyxl", mode=mode, **writer_kwargs) as writer:
        di_rec.to_excel(writer, sheet_name=f"DI_PERCENTUAL ({nome_data(dt_rec)})", index=False)
        ipca_rec.to_excel(writer, sheet_name=f"IPCA_SPREAD ({nome_data(dt_rec)})", index=False)

        di_old.to_excel(writer, sheet_name=f"DI_PERCENTUAL ({nome_data(dt_old)})", index=False)
        ipca_old.to_excel(writer, sheet_name=f"IPCA_SPREAD ({nome_data(dt_old)})", index=False)

    print(f"\nüíæ OK! Salvo em '{EXCEL_DESTINO}' com as datas {nome_data(dt_rec)} (recente) e {nome_data(dt_old)} (antiga).\n")


if __name__ == "__main__":
    main()
