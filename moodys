import os
import glob
import re
import unicodedata
from openpyxl import load_workbook, Workbook

# ================= CONFIG (AJUSTE AQUI) =================
SOURCE_PATH = ""  # ex: r"/Users/henriquepiscopo/Downloads/MOODYS_LOCAL_BRAZIL_20260119_000238.xlsx"
SHEET_NAME = "ML Brazil"
OUT_PATH = os.path.join(os.path.expanduser("~"), "Downloads", "MOODYS_LOCAL_BRAZIL_tratado.xlsx")
FILENAME_PREFIX = "MOODYS_LOCAL_BRAZIL_"
# ========================================================


def find_latest_in_downloads(prefix: str) -> str:
    downloads = os.path.join(os.path.expanduser("~"), "Downloads")
    pattern = os.path.join(downloads, f"{prefix}*.xlsx")
    hits = sorted(glob.glob(pattern), key=os.path.getmtime, reverse=True)
    if not hits:
        raise FileNotFoundError(f"NÃ£o achei arquivo em {downloads} com padrÃ£o: {prefix}*.xlsx")
    return hits[0]


def norm_text(s: str) -> str:
    if s is None:
        return ""
    s = str(s).strip().lower()
    s = unicodedata.normalize("NFKD", s)
    s = "".join(ch for ch in s if not unicodedata.combining(ch))
    s = " ".join(s.split())
    return s


def limpar_coluna_c_texto(s: str) -> str:
    if s is None:
        return ""
    s = str(s)
    s = re.sub(r"\s*\([^)]*\)", "", s)
    s = re.split(r"\s-\s", s, maxsplit=1)[0]
    s = " ".join(s.strip().split())
    return s


def fmt_ordinal_pt(num: str, suf: str) -> str:
    n = num.strip()
    s = (suf or "").strip().lower()
    if s in ("a", "Âª"):
        return f"{n}Âª"
    if s in ("o", "Âº"):
        return f"{n}Âº"
    return n


def ajustar_coluna_e(s: str) -> str:
    if s is None:
        return ""
    s = " ".join(str(s).strip().split())
    if s == "":
        return ""

    s = re.sub(r"\s-\s", " â€“ ", s)

    s = re.sub(
        r"^(\d+)\s*([ÂªaÂºo])?\s+(Emiss[aÃ£]o\b)",
        lambda m: f"{m.group(1)}Âª {m.group(3)}",
        s,
        flags=re.I
    )

    def repl_serie(m):
        num = m.group(1)
        suf = m.group(2) or ""
        if suf.strip() == "":
            return f" â€“ {num}Âª SÃ©rie"
        return f" â€“ {fmt_ordinal_pt(num, suf)} SÃ©rie"

    s = re.sub(
        r"\s[â€“-]\s*(\d+)\s*([ÂªaÂºo])?\s*S[eÃ©]rie\b",
        repl_serie,
        s,
        flags=re.I
    )

    s_norm = norm_text(s)
    if s_norm.endswith("emissao de debentures") and ("serie unica" not in s_norm):
        s = s + " â€“ SÃ©rie Ãšnica"

    return s


def autofit_columns(ws):
    for col_cells in ws.columns:
        max_len = 0
        col_letter = col_cells[0].column_letter
        for cell in col_cells:
            try:
                if cell.value not in (None, ""):
                    max_len = max(max_len, len(str(cell.value)))
            except Exception:
                pass
        ws.column_dimensions[col_letter].width = max_len + 2


def preencher_concat_em_todas_as_linhas(ws):
    """
    Garante que em cada linha r:
      A(r) = C(r) & " " & E(r)
    Importante: fazer ISSO DEPOIS dos filtros/exclusÃµes,
    para nÃ£o ficar desalinhado quando linhas forem deletadas.
    """
    last = ws.max_row
    if last >= 2:
        ws["A2"].value = '=C2&" "&E2'
        for r in range(3, last + 1):
            ws.cell(row=r, column=1).value = f'=C{r}&" "&E{r}'


def main():
    src_path = SOURCE_PATH.strip() or find_latest_in_downloads(FILENAME_PREFIX)
    print("ðŸ“„ Fonte:", src_path)

    wb_src = load_workbook(src_path, data_only=False)
    if SHEET_NAME not in wb_src.sheetnames:
        raise RuntimeError(f"Aba '{SHEET_NAME}' nÃ£o existe. Abas: {wb_src.sheetnames}")
    ws_src = wb_src[SHEET_NAME]

    wb_out = Workbook()
    ws_out = wb_out.active
    ws_out.title = SHEET_NAME

    # 1) Copiar da linha 4 pra baixo (linha 4 vira linha 1)
    out_r = 1
    for r in range(4, ws_src.max_row + 1):
        for c in range(1, ws_src.max_column + 1):
            ws_out.cell(row=out_r, column=c).value = ws_src.cell(row=r, column=c).value
        out_r += 1

    # 2) Inserir nova coluna A (desloca tudo 1 pra direita)
    ws_out.insert_cols(1)

    # 3) FILTRO COLUNA E (DebÃªntures) â€” apaga linha inteira
    for r in range(ws_out.max_row, 1, -1):
        e_val = norm_text(ws_out.cell(row=r, column=5).value)  # E
        if "debenture" not in e_val:
            ws_out.delete_rows(r, 1)

    # 4) FILTRO COLUNA B (somente dois valores permitidos) â€” apaga linha inteira
    permitidos = {
        norm_text("Projetos de Infraestrutura"),
        norm_text("Empresas NÃ£o-Financeiras"),
    }
    for r in range(ws_out.max_row, 1, -1):
        b_val = norm_text(ws_out.cell(row=r, column=2).value)  # B
        if b_val not in permitidos:
            ws_out.delete_rows(r, 1)

    # 5) LIMPAR COLUNA C (texto), exceto linhas 250â€“252 (na planilha final)
    excecoes = {250, 251, 252}
    for r in range(1, ws_out.max_row + 1):
        if r in excecoes:
            continue
        ws_out.cell(row=r, column=3).value = limpar_coluna_c_texto(ws_out.cell(row=r, column=3).value)

    # 6) AJUSTAR COLUNA E (emissÃ£o + sÃ©rie + sÃ©rie Ãºnica)
    for r in range(1, ws_out.max_row + 1):
        ws_out.cell(row=r, column=5).value = ajustar_coluna_e(ws_out.cell(row=r, column=5).value)

    # 7) CONCATENAÃ‡ÃƒO (FAZER POR ÃšLTIMO ENTRE AS TRANSFORMAÃ‡Ã•ES)
    #    para garantir que linha 16 concatena C16/E16 (e nÃ£o outra)
    preencher_concat_em_todas_as_linhas(ws_out)

    # 8) AutoFit DEPOIS DE TUDO (Ãºltima etapa antes de salvar)
    autofit_columns(ws_out)

    wb_out.save(OUT_PATH)
    print("âœ… Salvo:", OUT_PATH)


if __name__ == "__main__":
    main()

