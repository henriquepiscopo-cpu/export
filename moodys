import os
import glob
import re
import unicodedata
from openpyxl import load_workbook, Workbook

# ================= CONFIG (AJUSTE AQUI) =================
SOURCE_PATH = ""  # ex: r"/Users/henriquepiscopo/Downloads/MOODYS_LOCAL_BRAZIL_20260119_000238.xlsx"
SHEET_NAME = "ML Brazil"
OUT_PATH = os.path.join(os.path.expanduser("~"), "Downloads", "MOODYS_LOCAL_BRAZIL_tratado.xlsx")
FILENAME_PREFIX = "MOODYS_LOCAL_BRAZIL_"
# ========================================================


def find_latest_in_downloads(prefix: str) -> str:
    downloads = os.path.join(os.path.expanduser("~"), "Downloads")
    pattern = os.path.join(downloads, f"{prefix}*.xlsx")
    hits = sorted(glob.glob(pattern), key=os.path.getmtime, reverse=True)
    if not hits:
        raise FileNotFoundError(f"NÃ£o achei arquivo em {downloads} com padrÃ£o: {prefix}*.xlsx")
    return hits[0]


def norm_text(s: str) -> str:
    if s is None:
        return ""
    s = str(s).strip().lower()
    s = unicodedata.normalize("NFKD", s)
    s = "".join(ch for ch in s if not unicodedata.combining(ch))
    s = " ".join(s.split())
    return s


def limpar_coluna_c_texto(s: str) -> str:
    if s is None:
        return ""
    s = str(s)
    s = re.sub(r"\s*\([^)]*\)", "", s)          # remove ( ... )
    s = re.split(r"\s-\s", s, maxsplit=1)[0]    # remove " - ..." Ã  direita
    s = " ".join(s.strip().split())
    return s


def fmt_ordinal_pt(num: str, suf: str) -> str:
    n = num.strip()
    s = (suf or "").strip().lower()
    if s in ("a", "Âª"):
        return f"{n}Âª"
    if s in ("o", "Âº"):
        return f"{n}Âº"
    return n


def ajustar_coluna_e(s: str) -> str:
    """
    Regras coluna E:
    1) Garantir ordinal na emissÃ£o no comeÃ§o: "4 EmissÃ£o..." -> "4Âª EmissÃ£o..."
    2) Garantir ordinal na sÃ©rie: "- 1a SÃ©rie" / "â€“ 1a SÃ©rie" -> "â€“ 1Âª SÃ©rie"
    3) Se terminar exatamente com "EmissÃ£o de DebÃªntures", acrescentar " â€“ SÃ©rie Ãšnica"
    """
    if s is None:
        return ""
    s = " ".join(str(s).strip().split())
    if s == "":
        return ""

    # padroniza hÃ­fen com espaÃ§os para EN DASH
    s = re.sub(r"\s-\s", " â€“ ", s)

    # 1) "4 EmissÃ£o" / "4a EmissÃ£o" / "4Âª EmissÃ£o" -> "4Âª EmissÃ£o"
    s = re.sub(
        r"^(\d+)\s*([ÂªaÂºo])?\s+(Emiss[aÃ£]o\b)",
        lambda m: f"{m.group(1)}Âª {m.group(3)}",
        s,
        flags=re.I
    )

    # 2) "... â€“ 1a SÃ©rie" -> "... â€“ 1Âª SÃ©rie"
    def repl_serie(m):
        num = m.group(1)
        suf = m.group(2) or ""
        if suf.strip() == "":
            return f" â€“ {num}Âª SÃ©rie"
        return f" â€“ {fmt_ordinal_pt(num, suf)} SÃ©rie"

    s = re.sub(
        r"\s[â€“-]\s*(\d+)\s*([ÂªaÂºo])?\s*S[eÃ©]rie\b",
        repl_serie,
        s,
        flags=re.I
    )

    # 3) Se terminar com "EmissÃ£o de DebÃªntures", acrescenta " â€“ SÃ©rie Ãšnica"
    s_norm = norm_text(s)
    if s_norm.endswith("emissao de debentures") and ("serie unica" not in s_norm):
        s = s + " â€“ SÃ©rie Ãšnica"

    return s


def padronizar_coluna_b(s: str) -> str:
    """
    Coluna B (a partir da linha 2):
    deixar APENAS:
      - "Empresas NÃ£o-Financeiras"
      - "Projetos de Infraestrutura"

    HeurÃ­stica:
      - se o texto tiver "infra" -> Projetos de Infraestrutura
      - caso contrÃ¡rio -> Empresas NÃ£o-Financeiras
    """
    txt = norm_text(s)
    if "infra" in txt:
        return "Projetos de Infraestrutura"
    return "Empresas NÃ£o-Financeiras"


def autofit_columns(ws):
    for col_cells in ws.columns:
        max_len = 0
        col_letter = col_cells[0].column_letter
        for cell in col_cells:
            try:
                if cell.value is not None and str(cell.value) != "":
                    max_len = max(max_len, len(str(cell.value)))
            except Exception:
                pass
        ws.column_dimensions[col_letter].width = max_len + 2


def main():
    src_path = SOURCE_PATH.strip() or find_latest_in_downloads(FILENAME_PREFIX)
    print("ðŸ“„ Fonte:", src_path)

    wb_src = load_workbook(src_path, data_only=False)
    if SHEET_NAME not in wb_src.sheetnames:
        raise RuntimeError(f"Aba '{SHEET_NAME}' nÃ£o existe. Abas: {wb_src.sheetnames}")

    ws_src = wb_src[SHEET_NAME]
    max_row = ws_src.max_row
    max_col = ws_src.max_column
    if max_row < 4:
        raise RuntimeError("A planilha tem menos de 4 linhas; nÃ£o dÃ¡ para copiar a partir da linha 4.")

    wb_out = Workbook()
    ws_out = wb_out.active
    ws_out.title = SHEET_NAME

    # 1) Copiar da linha 4 pra baixo, linha 4 vira linha 1
    out_r = 1
    for r in range(4, max_row + 1):
        for c in range(1, max_col + 1):
            ws_out.cell(row=out_r, column=c).value = ws_src.cell(row=r, column=c).value
        out_r += 1

    # 2) Deslocar uma coluna para a direita (insere nova coluna A)
    ws_out.insert_cols(1)

    # 3) A2 = concat (nova C com nova E) COM ESPAÃ‡O + puxar para baixo
    ws_out["A2"].value = '=C2&" "&E2'
    last = ws_out.max_row
    for r in range(3, last + 1):
        ws_out.cell(row=r, column=1).value = f'=C{r}&" "&E{r}'

    # 4) FILTRO (APENAS coluna E)
    #    -> remover linhas (a partir da linha 2) se coluna E NÃƒO contiver "debenture" (variaÃ§Ãµes/acentos ok)
    target_sub = "debenture"
    for r in range(ws_out.max_row, 1, -1):
        e_val = norm_text(ws_out.cell(row=r, column=5).value)  # E
        if r >= 2 and (target_sub not in e_val):
            ws_out.delete_rows(r, 1)

    # 5) Coluna B (a partir da linha 2): padronizar para 2 categorias
    last = ws_out.max_row
    for r in range(2, last + 1):
        ws_out.cell(row=r, column=2).value = padronizar_coluna_b(ws_out.cell(row=r, column=2).value)

    # 6) LIMPAR COLUNA C (texto), exceto linhas 250-252 (na planilha final)
    excecoes = {250, 251, 252}
    last = ws_out.max_row
    for r in range(1, last + 1):
        if r in excecoes:
            continue
        val = ws_out.cell(row=r, column=3).value  # C
        if val is None or str(val).strip() == "":
            continue
        ws_out.cell(row=r, column=3).value = limpar_coluna_c_texto(val)

    # 7) AJUSTAR COLUNA E (emissÃ£o + sÃ©rie + sÃ©rie Ãºnica)
    last = ws_out.max_row
    for r in range(1, last + 1):
        val = ws_out.cell(row=r, column=5).value  # E
        if val is None or str(val).strip() == "":
            continue
        ws_out.cell(row=r, column=5).value = ajustar_coluna_e(val)

    # 8) AutoFit column widths na planilha toda
    autofit_columns(ws_out)

    wb_out.save(OUT_PATH)
    print("âœ… Salvo:", OUT_PATH)


if __name__ == "__main__":
    main()

