import os
import certifi
import requests
from datetime import date
from urllib.parse import urljoin
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

STRAPI_BASE = "https://data-strapi.prd.anbima.com.br"
TIMEOUT = (10, 120)

HEADERS = {
    "User-Agent": "Mozilla/5.0",
    "Accept": "application/json, text/plain, */*",
    "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8",
    "Origin": "https://data.anbima.com.br",
    "Referer": "https://data.anbima.com.br/",
    "Cache-Control": "no-cache",
    "Pragma": "no-cache",
}

# Mapeia nomes de meses que podem aparecer no slug/título
MESES = {
    1: ["janeiro", "jan"],
    2: ["fevereiro", "fev"],
    3: ["marco", "março", "mar"],
    4: ["abril", "abr"],
    5: ["maio", "mai"],
    6: ["junho", "jun"],
    7: ["julho", "jul"],
    8: ["agosto", "ago"],
    9: ["setembro", "set"],
    10: ["outubro", "out"],
    11: ["novembro", "nov"],
    12: ["dezembro", "dez"],
}


def build_session() -> requests.Session:
    s = requests.Session()
    retry = Retry(
        total=5,
        backoff_factor=0.8,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET"],
    )
    s.mount("https://", HTTPAdapter(max_retries=retry))
    return s


def mes_anterior(hoje: date) -> int:
    return 12 if hoje.month == 1 else hoje.month - 1


def texto_contém_mes(texto: str, mes_num: int) -> bool:
    if not texto:
        return False
    t = texto.lower()
    return any(m in t for m in MESES[mes_num])


def extrair_campos_para_validacao(item: dict) -> dict:
    """
    Tenta pegar slug/titulo/nome do arquivo do JSON, sem quebrar se algum não existir.
    """
    attrs = item.get("attributes") or {}
    template = attrs.get("template") or {}

    slug = template.get("slug") or ""
    titulo = template.get("title") or template.get("titulo") or attrs.get("title") or attrs.get("titulo") or ""

    # attachment name/url
    att_data = None
    try:
        att_data = template["attachment"]["data"]
        if isinstance(att_data, list):
            att_data = att_data[0]
    except Exception:
        att_data = None

    att_name = ""
    att_url = ""
    if isinstance(att_data, dict):
        att_attrs = att_data.get("attributes") or {}
        att_name = att_attrs.get("name") or ""
        att_url = att_attrs.get("url") or ""

    return {
        "slug": slug,
        "titulo": titulo,
        "att_name": att_name,
        "att_url": att_url,
        "publishedAt": attrs.get("publishedAt") or "",
    }


def get_latest_item_with_xlsx(session: requests.Session) -> dict:
    """
    Pega os itens mais recentes e retorna o primeiro que tiver attachment .xlsx.
    """
    url = f"{STRAPI_BASE}/api/boletim-de-fundos-de-investimentos"
    params = {
        "locale": "pt-BR",
        "sort": "publishedAt:desc",
        "pagination[pageSize]": "20",
        "populate": "template.attachment",
    }

    r = session.get(url, headers=HEADERS, params=params, timeout=TIMEOUT, verify=certifi.where())
    r.raise_for_status()

    for item in r.json().get("data", []):
        campos = extrair_campos_para_validacao(item)
        att_url = campos["att_url"]
        if isinstance(att_url, str) and att_url.lower().endswith(".xlsx"):
            return item

    raise RuntimeError("Não encontrei nenhum boletim recente com attachment .xlsx.")


def download_file(session: requests.Session, file_url: str, out_name: str):
    if file_url.startswith("/"):
        file_url = urljoin(STRAPI_BASE, file_url)

    with session.get(file_url, headers={"Accept": "*/*"}, stream=True, timeout=TIMEOUT, verify=certifi.where()) as r:
        r.raise_for_status()
        with open(out_name, "wb") as f:
            for chunk in r.iter_content(1024 * 256):
                if chunk:
                    f.write(chunk)


def main():
    s = build_session()

    hoje = date.today()
    mes_prev = mes_anterior(hoje)

    item = get_latest_item_with_xlsx(s)
    campos = extrair_campos_para_validacao(item)

    # ✅ valida o mês pelo slug/titulo/nome do arquivo
    base_text = " | ".join([campos["slug"], campos["titulo"], campos["att_name"]]).strip()
    if not texto_contém_mes(base_text, mes_prev):
        raise RuntimeError(
            "O XLSX mais recente encontrado NÃO parece ser do mês anterior.\n"
            f"- Hoje: {hoje.strftime('%d/%m/%Y')}\n"
            f"- Mês anterior esperado: {MESES[mes_prev][0]}\n"
            f"- publishedAt: {campos['publishedAt']}\n"
            f"- slug: {campos['slug']}\n"
            f"- titulo: {campos['titulo']}\n"
            f"- arquivo: {campos['att_name']}\n"
            f"- url: {campos['att_url']}\n"
            "\nSe isso estiver correto (ex.: ANBIMA atrasou ou adiantou publicação), "
            "você pode relaxar essa validação."
        )

    # Nome final (do jeito que você quer)
    ano_ref = hoje.year - 1 if hoje.month == 1 else hoje.year
    nome_mes = MESES[mes_prev][0]
    filename = f"Boletim_Fundos_{nome_mes}_{ano_ref}.xlsx"

    print(f"✅ OK: boletim bate com o mês anterior ({nome_mes})")
    print(f"⬇️ Baixando: {campos['att_url']}")
    download_file(s, campos["att_url"], filename)
    print(f"✅ Salvo em: {os.path.abspath(filename)}")


if __name__ == "__main__":
    main()
